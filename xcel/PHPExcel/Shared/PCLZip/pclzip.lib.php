<?php
// --------------------------------------------------------------------------------
// PhpConcept Library - Zip Module 2.8.2
// --------------------------------------------------------------------------------
// License GNU/LGPL - Vincent Blavet - August 2009
// http://www.phpconcept.net
// --------------------------------------------------------------------------------
//
// Presentation :
//     PclZip is a PHP library that manage ZIP archives.
//     So far tests show that archives generated by PclZip are readable by
//     WinZip application and other tools.
//
// Description :
//     See readme.txt and http://www.phpconcept.net
//
// Warning :
//     This library and the associated files are non commercial, non professional
//     work.
//     It should not have unexpected results. However if any damage is caused by
//     this software the author can not be responsible.
//     The use of this software is at the risk of the user.
//
// --------------------------------------------------------------------------------
// $Id: pclzip.lib.php,v 1.60 2009/09/30 21:01:04 vblavet Exp $
// --------------------------------------------------------------------------------

// ----- Constants
if (!defined('PCLZIP_READ_BLOCK_SIZE')) {
    define('PCLZIP_READ_BLOCK_SIZE', 2048);
}

// ----- File list separator
// In version 1.x of PclZip, the separator for file list is a space
// (which is not a very smart choice, specifically for windows paths !).
// A better separator should be a comma (,). This constant gives you the
// abilty to change that.
// However notice that changing this value, may have impact on existing
// scripts, using space separated filenames.
// Recommanded values for compatibility with older versions :
//define('PCLZIP_SEPARATOR', ' ');
// Recommanded values for smart separation of filenames.
if (!defined('PCLZIP_SEPARATOR')) {
    define('PCLZIP_SEPARATOR', ',');
}

// ----- Error configuration
// 0 : PclZip Class integrated error handling
// 1 : PclError external library error handling. By enabling this
//         you must ensure that you have included PclError library.
// [2,...] : reserved for futur use
if (!defined('PCLZIP_ERROR_EXTERNAL')) {
    define('PCLZIP_ERROR_EXTERNAL', 0);
}

// ----- Optional static temporary directory
//             By default temporary files are generated in the script current
//             path.
//             If defined :
//             - MUST BE terminated by a '/'.
//             - MUST be a valid, already created directory
//             Samples :
// define('PCLZIP_TEMPORARY_DIR', '/temp/');
// define('PCLZIP_TEMPORARY_DIR', 'C:/Temp/');
if (!defined('PCLZIP_TEMPORARY_DIR')) {
    define('PCLZIP_TEMPORARY_DIR', '');
}

// ----- Optional threshold ratio for use of temporary files
//             Pclzip sense the size of the file to add/extract and decide to
//             use or not temporary file. The algorythm is looking for
//             memory_limit of PHP and apply a ratio.
//             threshold = memory_limit * ratio.
//             Recommended values are under 0.5. Default 0.47.
//             Samples :
// define('PCLZIP_TEMPORARY_FILE_RATIO', 0.5);
if (!defined('PCLZIP_TEMPORARY_FILE_RATIO')) {
    define('PCLZIP_TEMPORARY_FILE_RATIO', 0.47);
}

// --------------------------------------------------------------------------------
// ***** UNDER THIS LINE NOTHING NEEDS TO BE MODIFIED *****
// --------------------------------------------------------------------------------

// ----- Global variables
$g_pclzip_version = "2.8.2";

// ----- Error codes
//     -1 : Unable to open file in binary write mode
//     -2 : Unable to open file in binary read mode
//     -3 : Invalid parameters
//     -4 : File does not exist
//     -5 : Filename is too long (max. 255)
//     -6 : Not a valid zip file
//     -7 : Invalid extracted file size
//     -8 : Unable to create directory
//     -9 : Invalid archive extension
//    -10 : Invalid archive format
//    -11 : Unable to delete file (unlink)
//    -12 : Unable to rename file (rename)
//    -13 : Invalid header checksum
//    -14 : Invalid archive size
define('PCLZIP_ERR_USER_ABORTED', 2);
define('PCLZIP_ERR_NO_ERROR', 0);
define('PCLZIP_ERR_WRITE_OPEN_FAIL', -1);
define('PCLZIP_ERR_READ_OPEN_FAIL', -2);
define('PCLZIP_ERR_INVALID_PARAMETER', -3);
define('PCLZIP_ERR_MISSING_FILE', -4);
define('PCLZIP_ERR_FILENAME_TOO_LONG', -5);
define('PCLZIP_ERR_INVALID_ZIP', -6);
define('PCLZIP_ERR_BAD_EXTRACTED_FILE', -7);
define('PCLZIP_ERR_DIR_CREATE_FAIL', -8);
define('PCLZIP_ERR_BAD_EXTENSION', -9);
define('PCLZIP_ERR_BAD_FORMAT', -10);
define('PCLZIP_ERR_DELETE_FILE_FAIL', -11);
define('PCLZIP_ERR_RENAME_FILE_FAIL', -12);
define('PCLZIP_ERR_BAD_CHECKSUM', -13);
define('PCLZIP_ERR_INVALID_ARCHIVE_ZIP', -14);
define('PCLZIP_ERR_MISSING_OPTION_VALUE', -15);
define('PCLZIP_ERR_INVALID_OPTION_VALUE', -16);
define('PCLZIP_ERR_ALREADY_A_DIRECTORY', -17);
define('PCLZIP_ERR_UNSUPPORTED_COMPRESSION', -18);
define('PCLZIP_ERR_UNSUPPORTED_ENCRYPTION', -19);
define('PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE', -20);
define('PCLZIP_ERR_DIRECTORY_RESTRICTION', -21);

// ----- Options values
define('PCLZIP_OPT_PATH', 77001);
define('PCLZIP_OPT_ADD_PATH', 77002);
define('PCLZIP_OPT_REMOVE_PATH', 77003);
define('PCLZIP_OPT_REMOVE_ALL_PATH', 77004);
define('PCLZIP_OPT_SET_CHMOD', 77005);
define('PCLZIP_OPT_EXTRACT_AS_STRING', 77006);
define('PCLZIP_OPT_NO_COMPRESSION', 77007);
define('PCLZIP_OPT_BY_NAME', 77008);
define('PCLZIP_OPT_BY_INDEX', 77009);
define('PCLZIP_OPT_BY_EREG', 77010);
define('PCLZIP_OPT_BY_PREG', 77011);
define('PCLZIP_OPT_COMMENT', 77012);
define('PCLZIP_OPT_ADD_COMMENT', 77013);
define('PCLZIP_OPT_PREPEND_COMMENT', 77014);
define('PCLZIP_OPT_EXTRACT_IN_OUTPUT', 77015);
define('PCLZIP_OPT_REPLACE_NEWER', 77016);
define('PCLZIP_OPT_STOP_ON_ERROR', 77017);
// Having big trouble with crypt. Need to multiply 2 long int
// which is not correctly supported by PHP ...
//define('PCLZIP_OPT_CRYPT', 77018);
define('PCLZIP_OPT_EXTRACT_DIR_RESTRICTION', 77019);
define('PCLZIP_OPT_TEMP_FILE_THRESHOLD', 77020);
define('PCLZIP_OPT_ADD_TEMP_FILE_THRESHOLD', 77020); // alias
define('PCLZIP_OPT_TEMP_FILE_ON', 77021);
define('PCLZIP_OPT_ADD_TEMP_FILE_ON', 77021); // alias
define('PCLZIP_OPT_TEMP_FILE_OFF', 77022);
define('PCLZIP_OPT_ADD_TEMP_FILE_OFF', 77022); // alias

// ----- File description attributes
define('PCLZIP_ATT_FILE_NAME', 79001);
define('PCLZIP_ATT_FILE_NEW_SHORT_NAME', 79002);
define('PCLZIP_ATT_FILE_NEW_FULL_NAME', 79003);
define('PCLZIP_ATT_FILE_MTIME', 79004);
define('PCLZIP_ATT_FILE_CONTENT', 79005);
define('PCLZIP_ATT_FILE_COMMENT', 79006);

// ----- Call backs values
define('PCLZIP_CB_PRE_EXTRACT', 78001);
define('PCLZIP_CB_POST_EXTRACT', 78002);
define('PCLZIP_CB_PRE_ADD', 78003);
define('PCLZIP_CB_POST_ADD', 78004);
/* For futur use
define('PCLZIP_CB_PRE_LIST', 78005);
define('PCLZIP_CB_POST_LIST', 78006);
define('PCLZIP_CB_PRE_DELETE', 78007);
define('PCLZIP_CB_POST_DELETE', 78008);
*/

// --------------------------------------------------------------------------------
// Class : PclZip
// Description :
//     PclZip is the class that represent a Zip archive.
//     The public methods allow the manipulation of the archive.
// Attributes :
//     Attributes must not be accessed directly.
// Methods :
//     PclZip() : Object creator
//     create() : Creates the Zip archive
//     listContent() : List the content of the Zip archive
//     extract() : Extract the content of the archive
//     properties() : List the properties of the archive
// --------------------------------------------------------------------------------
class PclZip
{
    // ----- Filename of the zip file
    public $zipname = '';

    // ----- File descriptor of the zip file
    public $zip_fd = 0;

    // ----- Internal error handling
    public $error_code = 1;
    public $error_string = '';

    // ----- Current status of the magic_quotes_runtime
    // This value store the php configuration for magic_quotes
    // The class can then disable the magic_quotes and reset it after
    public $magic_quotes_status;

    // --------------------------------------------------------------------------------
    // Function : PclZip()
    // Description :
    //     Creates a PclZip object and set the name of the associated Zip archive
    //     filename.
    //     Note that no real action is taken, if the archive does not exist it is not
    //     created. Use create() for that.
    // --------------------------------------------------------------------------------
    public function __construct($p_zipname)
    {

        // ----- Tests the zlib
        if (!function_exists('gzopen')) {
            die('Abort '.basename(__FILE__).' : Missing zlib extensions');
        }

        // ----- Set the attributes
        $this->zipname = $p_zipname;
        $this->zip_fd = 0;
        $this->magic_quotes_status = -1;

        // ----- Return
        return;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function :
    //     create($p_filelist, $p_add_dir="", $p_remove_dir="")
    //     create($p_filelist, $p_option, $p_option_value, ...)
    // Description :
    //     This method supports two different synopsis. The first one is historical.
    //     This method creates a Zip Archive. The Zip file is created in the
    //     filesystem. The files and directories indicated in $p_filelist
    //     are added in the archive. See the parameters description for the
    //     supported format of $p_filelist.
    //     When a directory is in the list, the directory and its content is added
    //     in the archive.
    //     In this synopsis, the function takes an optional variable list of
    //     options. See bellow the supported options.
    // Parameters :
    //     $p_filelist : An array containing file or directory names, or
    //                                 a string containing one filename or one directory name, or
    //                                 a string containing a list of filenames and/or directory
    //                                 names separated by spaces.
    //     $p_add_dir : A path to add before the real path of the archived file,
    //                                in order to have it memorized in the archive.
    //     $p_remove_dir : A path to remove from the real path of the file to archive,
    //                                     in order to have a shorter path memorized in the archive.
    //                                     When $p_add_dir and $p_remove_dir are set, $p_remove_dir
    //                                     is removed first, before $p_add_dir is added.
    // Options :
    //     PCLZIP_OPT_ADD_PATH :
    //     PCLZIP_OPT_REMOVE_PATH :
    //     PCLZIP_OPT_REMOVE_ALL_PATH :
    //     PCLZIP_OPT_COMMENT :
    //     PCLZIP_CB_PRE_ADD :
    //     PCLZIP_CB_POST_ADD :
    // Return Values :
    //     0 on failure,
    //     The list of the added files, with a status of the add action.
    //     (see PclZip::listContent() for list entry format)
    // --------------------------------------------------------------------------------
    public function create($p_filelist)
    {
        $v_result=1;

        // ----- Reset the error handler
        $this->privErrorReset();

        // ----- Set default values
        $v_options = array();
        $v_options[PCLZIP_OPT_NO_COMPRESSION] = false;

        // ----- Look for variable options arguments
        $v_size = func_num_args();

        // ----- Look for arguments
        if ($v_size > 1) {
            // ----- Get the arguments
            $v_arg_list = func_get_args();

            // ----- Remove from the options list the first argument
            array_shift($v_arg_list);
            $v_size--;

            // ----- Look for first arg
            if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {
                // ----- Parse the options
                $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options, array (
                    PCLZIP_OPT_REMOVE_PATH => 'optional',
                    PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',
                    PCLZIP_OPT_ADD_PATH => 'optional',
                    PCLZIP_CB_PRE_ADD => 'optional',
                    PCLZIP_CB_POST_ADD => 'optional',
                    PCLZIP_OPT_NO_COMPRESSION => 'optional',
                    PCLZIP_OPT_COMMENT => 'optional',
                    PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',
                    PCLZIP_OPT_TEMP_FILE_ON => 'optional',
                    PCLZIP_OPT_TEMP_FILE_OFF => 'optional'
                    //, PCLZIP_OPT_CRYPT => 'optional'
                ));
                if ($v_result != 1) {
                    return 0;
                }
            } else {
                // ----- Look for 2 args
                // Here we need to support the first historic synopsis of the
                // method.
                // ----- Get the first argument
                $v_options[PCLZIP_OPT_ADD_PATH] = $v_arg_list[0];

                // ----- Look for the optional second argument
                if ($v_size == 2) {
                    $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];
                } elseif ($v_size > 2) {
                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");
                    return 0;
                }
            }
        }

        // ----- Look for default option values
        $this->privOptionDefaultThreshold($v_options);

        // ----- Init
        $v_string_list = array();
        $v_att_list = array();
        $v_filedescr_list = array();
        $p_result_list = array();

        // ----- Look if the $p_filelist is really an array
        if (is_array($p_filelist)) {
            // ----- Look if the first element is also an array
            //             This will mean that this is a file description entry
            if (isset($p_filelist[0]) && is_array($p_filelist[0])) {
                $v_att_list = $p_filelist;
            } else {
                // ----- The list is a list of string names
                $v_string_list = $p_filelist;
            }
        } elseif (is_string($p_filelist)) {
            // ----- Look if the $p_filelist is a string
            // ----- Create a list from the string
            $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);
        } else {
            // ----- Invalid variable type for $p_filelist
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_filelist");
            return 0;
        }

        // ----- Reformat the string list
        if (sizeof($v_string_list) != 0) {
            foreach ($v_string_list as $v_string) {
                if ($v_string != '') {
                    $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;
                } else {
                }
            }
        }

        // ----- For each file in the list check the attributes
        $v_supported_attributes = array(
            PCLZIP_ATT_FILE_NAME => 'mandatory',
            PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional',
            PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional',
            PCLZIP_ATT_FILE_MTIME => 'optional',
            PCLZIP_ATT_FILE_CONTENT => 'optional',
            PCLZIP_ATT_FILE_COMMENT => 'optional'
        );
        foreach ($v_att_list as $v_entry) {
            $v_result = $this->privFileDescrParseAtt($v_entry, $v_filedescr_list[], $v_options, $v_supported_attributes);
            if ($v_result != 1) {
                return 0;
            }
        }

        // ----- Expand the filelist (expand directories)
        $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);
        if ($v_result != 1) {
            return 0;
        }

        // ----- Call the create fct
        $v_result = $this->privCreate($v_filedescr_list, $p_result_list, $v_options);
        if ($v_result != 1) {
            return 0;
        }

        // ----- Return
        return $p_result_list;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function :
    //     add($p_filelist, $p_add_dir="", $p_remove_dir="")
    //     add($p_filelist, $p_option, $p_option_value, ...)
    // Description :
    //     This method supports two synopsis. The first one is historical.
    //     This methods add the list of files in an existing archive.
    //     If a file with the same name already exists, it is added at the end of the
    //     archive, the first one is still present.
    //     If the archive does not exist, it is created.
    // Parameters :
    //     $p_filelist : An array containing file or directory names, or
    //                                 a string containing one filename or one directory name, or
    //                                 a string containing a list of filenames and/or directory
    //                                 names separated by spaces.
    //     $p_add_dir : A path to add before the real path of the archived file,
    //                                in order to have it memorized in the archive.
    //     $p_remove_dir : A path to remove from the real path of the file to archive,
    //                                     in order to have a shorter path memorized in the archive.
    //                                     When $p_add_dir and $p_remove_dir are set, $p_remove_dir
    //                                     is removed first, before $p_add_dir is added.
    // Options :
    //     PCLZIP_OPT_ADD_PATH :
    //     PCLZIP_OPT_REMOVE_PATH :
    //     PCLZIP_OPT_REMOVE_ALL_PATH :
    //     PCLZIP_OPT_COMMENT :
    //     PCLZIP_OPT_ADD_COMMENT :
    //     PCLZIP_OPT_PREPEND_COMMENT :
    //     PCLZIP_CB_PRE_ADD :
    //     PCLZIP_CB_POST_ADD :
    // Return Values :
    //     0 on failure,
    //     The list of the added files, with a status of the add action.
    //     (see PclZip::listContent() for list entry format)
    // --------------------------------------------------------------------------------
    public function add($p_filelist)
    {
        $v_result=1;

        // ----- Reset the error handler
        $this->privErrorReset();

        // ----- Set default values
        $v_options = array();
        $v_options[PCLZIP_OPT_NO_COMPRESSION] = false;

        // ----- Look for variable options arguments
        $v_size = func_num_args();

        // ----- Look for arguments
        if ($v_size > 1) {
            // ----- Get the arguments
            $v_arg_list = func_get_args();

            // ----- Remove form the options list the first argument
            array_shift($v_arg_list);
            $v_size--;

            // ----- Look for first arg
            if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {
                // ----- Parse the options
                $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options, array (
                    PCLZIP_OPT_REMOVE_PATH => 'optional',
                    PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',
                    PCLZIP_OPT_ADD_PATH => 'optional',
                    PCLZIP_CB_PRE_ADD => 'optional',
                    PCLZIP_CB_POST_ADD => 'optional',
                    PCLZIP_OPT_NO_COMPRESSION => 'optional',
                    PCLZIP_OPT_COMMENT => 'optional',
                    PCLZIP_OPT_ADD_COMMENT => 'optional',
                    PCLZIP_OPT_PREPEND_COMMENT => 'optional',
                    PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',
                    PCLZIP_OPT_TEMP_FILE_ON => 'optional',
                    PCLZIP_OPT_TEMP_FILE_OFF => 'optional'
                    //, PCLZIP_OPT_CRYPT => 'optional'
                ));
                if ($v_result != 1) {
                    return 0;
                }
            } else {
                // ----- Look for 2 args
                // Here we need to support the first historic synopsis of the
                // method.
                // ----- Get the first argument
                $v_options[PCLZIP_OPT_ADD_PATH] = $v_add_path = $v_arg_list[0];

                // ----- Look for the optional second argument
                if ($v_size == 2) {
                    $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];
                } elseif ($v_size > 2) {
                    // ----- Error log
                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");

                    // ----- Return
                    return 0;
                }
            }
        }

        // ----- Look for default option values
        $this->privOptionDefaultThreshold($v_options);

        // ----- Init
        $v_string_list = array();
        $v_att_list = array();
        $v_filedescr_list = array();
        $p_result_list = array();

        // ----- Look if the $p_filelist is really an array
        if (is_array($p_filelist)) {
            // ----- Look if the first element is also an array
            //             This will mean that this is a file description entry
            if (isset($p_filelist[0]) && is_array($p_filelist[0])) {
                $v_att_list = $p_filelist;
            } else {
                // ----- The list is a list of string names
                $v_string_list = $p_filelist;
            }
        } elseif (is_string($p_filelist)) {
            // ----- Look if the $p_filelist is a string
            // ----- Create a list from the string
            $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);
        } else {
            // ----- Invalid variable type for $p_filelist
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type '".gettype($p_filelist)."' for p_filelist");
            return 0;
        }

        // ----- Reformat the string list
        if (sizeof($v_string_list) != 0) {
            foreach ($v_string_list as $v_string) {
                $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;
            }
        }

        // ----- For each file in the list check the attributes
        $v_supported_attributes = array(
          PCLZIP_ATT_FILE_NAME => 'mandatory',
          PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional',
          PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional',
          PCLZIP_ATT_FILE_MTIME => 'optional',
          PCLZIP_ATT_FILE_CONTENT => 'optional',
          PCLZIP_ATT_FILE_COMMENT => 'optional',
        );
        foreach ($v_att_list as $v_entry) {
            $v_result = $this->privFileDescrParseAtt($v_entry, $v_filedescr_list[], $v_options, $v_supported_attributes);
            if ($v_result != 1) {
                return 0;
            }
        }

        // ----- Expand the filelist (expand directories)
        $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);
        if ($v_result != 1) {
            return 0;
        }

        // ----- Call the create fct
        $v_result = $this->privAdd($v_filedescr_list, $p_result_list, $v_options);
        if ($v_result != 1) {
            return 0;
        }

        // ----- Return
        return $p_result_list;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : listContent()
    // Description :
    //     This public method, gives the list of the files and directories, with their
    //     properties.
    //     The properties of each entries in the list are (used also in other functions) :
    //         filename : Name of the file. For a create or add action it is the filename
    //                                given by the user. For an extract function it is the filename
    //                                of the extracted file.
    //         stored_filename : Name of the file / directory stored in the archive.
    //         size : Size of the stored file.
    //         compressed_size : Size of the file's data compressed in the archive
    //                                             (without the headers overhead)
    //         mtime : Last known modification date of the file (UNIX timestamp)
    //         comment : Comment associated with the file
    //         folder : true | false
    //         index : index of the file in the archive
    //         status : status of the action (depending of the action) :
    //                            Values are :
    //                                ok : OK !
    //                                filtered : the file / dir is not extracted (filtered by user)
    //                                already_a_directory : the file can not be extracted because a
    //                                                                            directory with the same name already exists
    //                                write_protected : the file can not be extracted because a file
    //                                                                    with the same name already exists and is
    //                                                                    write protected
    //                                newer_exist : the file was not extracted because a newer file exists
    //                                path_creation_fail : the file is not extracted because the folder
    //                                                                         does not exist and can not be created
    //                                write_error : the file was not extracted because there was a
    //                                                            error while writing the file
    //                                read_error : the file was not extracted because there was a error
    //                                                         while reading the file
    //                                invalid_header : the file was not extracted because of an archive
    //                                                                 format error (bad file header)
    //     Note that each time a method can continue operating when there
    //     is an action error on a file, the error is only logged in the file status.
    // Return Values :
    //     0 on an unrecoverable failure,
    //     The list of the files in the archive.
    // --------------------------------------------------------------------------------
    public function listContent()
    {
        $v_result=1;

        // ----- Reset the error handler
        $this->privErrorReset();

        // ----- Check archive
        if (!$this->privCheckFormat()) {
            return(0);
        }

        // ----- Call the extracting fct
        $p_list = array();
        if (($v_result = $this->privList($p_list)) != 1) {
            unset($p_list);
            return(0);
        }

        // ----- Return
        return $p_list;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function :
    //     extract($p_path="./", $p_remove_path="")
    //     extract([$p_option, $p_option_value, ...])
    // Description :
    //     This method supports two synopsis. The first one is historical.
    //     This method extract all the files / directories from the archive to the
    //     folder indicated in $p_path.
    //     If you want to ignore the 'root' part of path of the memorized files
    //     you can indicate this in the optional $p_remove_path parameter.
    //     By default, if a newer file with the same name already exists, the
    //     file is not extracted.
    //
    //     If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH aoptions
    //     are used, the path indicated in PCLZIP_OPT_ADD_PATH is append
    //     at the end of the path value of PCLZIP_OPT_PATH.
    // Parameters :
    //     $p_path : Path where the files and directories are to be extracted
    //     $p_remove_path : First part ('root' part) of the memorized path
    //                                        (if any similar) to remove while extracting.
    // Options :
    //     PCLZIP_OPT_PATH :
    //     PCLZIP_OPT_ADD_PATH :
    //     PCLZIP_OPT_REMOVE_PATH :
    //     PCLZIP_OPT_REMOVE_ALL_PATH :
    //     PCLZIP_CB_PRE_EXTRACT :
    //     PCLZIP_CB_POST_EXTRACT :
    // Return Values :
    //     0 or a negative value on failure,
    //     The list of the extracted files, with a status of the action.
    //     (see PclZip::listContent() for list entry format)
    // --------------------------------------------------------------------------------
    public function extract()
    {
        $v_result=1;

        // ----- Reset the error handler
        $this->privErrorReset();

        // ----- Check archive
        if (!$this->privCheckFormat()) {
            return(0);
        }

        // ----- Set default values
        $v_options = array();
    //        $v_path = "./";
        $v_path = '';
        $v_remove_path = "";
        $v_remove_all_path = false;

        // ----- Look for variable options arguments
        $v_size = func_num_args();

        // ----- Default values for option
        $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = false;

        // ----- Look for arguments
        if ($v_size > 0) {
            // ----- Get the arguments
            $v_arg_list = func_get_args();

            // ----- Look for first arg
            if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {
                // ----- Parse the options
                $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options, array (
                  PCLZIP_OPT_PATH => 'optional',
                  PCLZIP_OPT_REMOVE_PATH => 'optional',
                  PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',
                  PCLZIP_OPT_ADD_PATH => 'optional',
                  PCLZIP_CB_PRE_EXTRACT => 'optional',
                  PCLZIP_CB_POST_EXTRACT => 'optional',
                  PCLZIP_OPT_SET_CHMOD => 'optional',
                  PCLZIP_OPT_BY_NAME => 'optional',
                  PCLZIP_OPT_BY_EREG => 'optional',
                  PCLZIP_OPT_BY_PREG => 'optional',
                  PCLZIP_OPT_BY_INDEX => 'optional',
                  PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',
                  PCLZIP_OPT_EXTRACT_IN_OUTPUT => 'optional',
                  PCLZIP_OPT_REPLACE_NEWER => 'optional',
                  PCLZIP_OPT_STOP_ON_ERROR => 'optional',
                  PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',
                  PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',
                  PCLZIP_OPT_TEMP_FILE_ON => 'optional',
                  PCLZIP_OPT_TEMP_FILE_OFF => 'optional'
                ));
                if ($v_result != 1) {
                    return 0;
                }

                // ----- Set the arguments
                if (isset($v_options[PCLZIP_OPT_PATH])) {
                    $v_path = $v_options[PCLZIP_OPT_PATH];
                }
                if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {
                    $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];
                }
                if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {
                    $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];
                }
                if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {
                    // ----- Check for '/' in last path char
                    if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {
                        $v_path .= '/';
                    }
                    $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];
                }
            } else {
                // ----- Look for 2 args
                // Here we need to support the first historic synopsis of the
                // method.
                // ----- Get the first argument
                $v_path = $v_arg_list[0];

                // ----- Look for the optional second argument
                if ($v_size == 2) {
                    $v_remove_path = $v_arg_list[1];
                } elseif ($v_size > 2) {
                    // ----- Error log
                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");

                    // ----- Return
                    return 0;
                }
            }
        }

        // ----- Look for default option values
        $this->privOptionDefaultThreshold($v_options);

        // ----- Trace

        // ----- Call the extracting fct
        $p_list = array();
        $v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options);
        if ($v_result < 1) {
            unset($p_list);
            return(0);
        }

        // ----- Return
        return $p_list;
    }
    // --------------------------------------------------------------------------------


    // --------------------------------------------------------------------------------
    // Function :
    //     extractByIndex($p_index, $p_path="./", $p_remove_path="")
    //     extractByIndex($p_index, [$p_option, $p_option_value, ...])
    // Description :
    //     This method supports two synopsis. The first one is historical.
    //     This method is doing a partial extract of the archive.
    //     The extracted files or folders are identified by their index in the
    //     archive (from 0 to n).
    //     Note that if the index identify a folder, only the folder entry is
    //     extracted, not all the files included in the archive.
    // Parameters :
    //     $p_index : A single index (integer) or a string of indexes of files to
    //                            extract. The form of the string is "0,4-6,8-12" with only numbers
    //                            and '-' for range or ',' to separate ranges. No spaces or ';'
    //                            are allowed.
    //     $p_path : Path where the files and directories are to be extracted
    //     $p_remove_path : First part ('root' part) of the memorized path
    //                                        (if any similar) to remove while extracting.
    // Options :
    //     PCLZIP_OPT_PATH :
    //     PCLZIP_OPT_ADD_PATH :
    //     PCLZIP_OPT_REMOVE_PATH :
    //     PCLZIP_OPT_REMOVE_ALL_PATH :
    //     PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and
    //         not as files.
    //         The resulting content is in a new field 'content' in the file
    //         structure.
    //         This option must be used alone (any other options are ignored).
    //     PCLZIP_CB_PRE_EXTRACT :
    //     PCLZIP_CB_POST_EXTRACT :
    // Return Values :
    //     0 on failure,
    //     The list of the extracted files, with a status of the action.
    //     (see PclZip::listContent() for list entry format)
    // --------------------------------------------------------------------------------
    //function extractByIndex($p_index, options...)
    public function extractByIndex($p_index)
    {
        $v_result=1;

        // ----- Reset the error handler
        $this->privErrorReset();

        // ----- Check archive
        if (!$this->privCheckFormat()) {
            return(0);
        }

        // ----- Set default values
        $v_options = array();
    //        $v_path = "./";
        $v_path = '';
        $v_remove_path = "";
        $v_remove_all_path = false;

        // ----- Look for variable options arguments
        $v_size = func_num_args();

        // ----- Default values for option
        $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = false;

        // ----- Look for arguments
        if ($v_size > 1) {
            // ----- Get the arguments
            $v_arg_list = func_get_args();

            // ----- Remove form the options list the first argument
            array_shift($v_arg_list);
            $v_size--;

            // ----- Look for first arg
            if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {
                // ----- Parse the options
                $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options, array(
                    PCLZIP_OPT_PATH => 'optional',
                    PCLZIP_OPT_REMOVE_PATH => 'optional',
                    PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',
                    PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',
                    PCLZIP_OPT_ADD_PATH => 'optional',
                    PCLZIP_CB_PRE_EXTRACT => 'optional',
                    PCLZIP_CB_POST_EXTRACT => 'optional',
                    PCLZIP_OPT_SET_CHMOD => 'optional',
                    PCLZIP_OPT_REPLACE_NEWER => 'optional',
                    PCLZIP_OPT_STOP_ON_ERROR => 'optional',
                    PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',
                    PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',
                    PCLZIP_OPT_TEMP_FILE_ON => 'optional',
                    PCLZIP_OPT_TEMP_FILE_OFF => 'optional'
                ));
                if ($v_result != 1) {
                    return 0;
                }

                // ----- Set the arguments
                if (isset($v_options[PCLZIP_OPT_PATH])) {
                    $v_path = $v_options[PCLZIP_OPT_PATH];
                }
                if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {
                    $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];
                }
                if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {
                    $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];
                }
                if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {
                    // ----- Check for '/' in last path char
                    if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {
                        $v_path .= '/';
                    }
                    $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];
                }
                if (!isset($v_options[PCLZIP_OPT_EXTRACT_AS_STRING])) {
                    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = false;
                } else {
                }
            } else {
                // ----- Look for 2 args
                // Here we need to support the first historic synopsis of the
                // method.

                // ----- Get the first argument
                $v_path = $v_arg_list[0];

                // ----- Look for the optional second argument
                if ($v_size == 2) {
                    $v_remove_path = $v_arg_list[1];
                } elseif ($v_size > 2) {
                    // ----- Error log
                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");

                    // ----- Return
                    return 0;
                }
            }
        }

        // ----- Trace

        // ----- Trick
        // Here I want to reuse extractByRule(), so I need to parse the $p_index
        // with privParseOptions()
        $v_arg_trick = array (PCLZIP_OPT_BY_INDEX, $p_index);
        $v_options_trick = array();
        $v_result = $this->privParseOptions($v_arg_trick, sizeof($v_arg_trick), $v_options_trick, array (PCLZIP_OPT_BY_INDEX => 'optional'));
        if ($v_result != 1) {
            return 0;
        }
        $v_options[PCLZIP_OPT_BY_INDEX] = $v_options_trick[PCLZIP_OPT_BY_INDEX];

        // ----- Look for default option values
        $this->privOptionDefaultThreshold($v_options);

        // ----- Call the extracting fct
        if (($v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options)) < 1) {
            return(0);
        }

        // ----- Return
        return $p_list;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function :
    //     delete([$p_option, $p_option_value, ...])
    // Description :
    //     This method removes files from the archive.
    //     If no parameters are given, then all the archive is emptied.
    // Parameters :
    //     None or optional arguments.
    // Options :
    //     PCLZIP_OPT_BY_INDEX :
    //     PCLZIP_OPT_BY_NAME :
    //     PCLZIP_OPT_BY_EREG :
    //     PCLZIP_OPT_BY_PREG :
    // Return Values :
    //     0 on failure,
    //     The list of the files which are still present in the archive.
    //     (see PclZip::listContent() for list entry format)
    // --------------------------------------------------------------------------------
    public function delete()
    {
        $v_result=1;

        // ----- Reset the error handler
        $this->privErrorReset();

        // ----- Check archive
        if (!$this->privCheckFormat()) {
            return(0);
        }

        // ----- Set default values
        $v_options = array();

        // ----- Look for variable options arguments
        $v_size = func_num_args();

        // ----- Look for arguments
        if ($v_size > 0) {
            // ----- Get the arguments
            $v_arg_list = func_get_args();

            // ----- Parse the options
            $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options, array (
                PCLZIP_OPT_BY_NAME => 'optional',
                PCLZIP_OPT_BY_EREG => 'optional',
                PCLZIP_OPT_BY_PREG => 'optional',
                PCLZIP_OPT_BY_INDEX => 'optional'
            ));
            if ($v_result != 1) {
                    return 0;
            }
        }

        // ----- Magic quotes trick
        $this->privDisableMagicQuotes();

        // ----- Call the delete fct
        $v_list = array();
        if (($v_result = $this->privDeleteByRule($v_list, $v_options)) != 1) {
            $this->privSwapBackMagicQuotes();
            unset($v_list);
            return(0);
        }

        // ----- Magic quotes trick
        $this->privSwapBackMagicQuotes();

        // ----- Return
        return $v_list;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : deleteByIndex()
    // Description :
    //     ***** Deprecated *****
    //     delete(PCLZIP_OPT_BY_INDEX, $p_index) should be prefered.
    // --------------------------------------------------------------------------------
    public function deleteByIndex($p_index)
    {

        $p_list = $this->delete(PCLZIP_OPT_BY_INDEX, $p_index);

        // ----- Return
        return $p_list;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : properties()
    // Description :
    //     This method gives the properties of the archive.
    //     The properties are :
    //         nb : Number of files in the archive
    //         comment : Comment associated with the archive file
    //         status : not_exist, ok
    // Parameters :
    //     None
    // Return Values :
    //     0 on failure,
    //     An array with the archive properties.
    // --------------------------------------------------------------------------------
    public function properties()
    {

        // ----- Reset the error handler
        $this->privErrorReset();

        // ----- Magic quotes trick
        $this->privDisableMagicQuotes();

        // ----- Check archive
        if (!$this->privCheckFormat()) {
            $this->privSwapBackMagicQuotes();
            return(0);
        }

        // ----- Default properties
        $v_prop = array();
        $v_prop['comment'] = '';
        $v_prop['nb'] = 0;
        $v_prop['status'] = 'not_exist';

        // ----- Look if file exists
        if (@is_file($this->zipname)) {
            // ----- Open the zip file
            if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0) {
                $this->privSwapBackMagicQuotes();

                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in binary read mode');

                // ----- Return
                return 0;
            }

            // ----- Read the central directory informations
            $v_central_dir = array();
            if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) {
                $this->privSwapBackMagicQuotes();
                return 0;
            }

            // ----- Close the zip file
            $this->privCloseFd();

            // ----- Set the user attributes
            $v_prop['comment'] = $v_central_dir['comment'];
            $v_prop['nb'] = $v_central_dir['entries'];
            $v_prop['status'] = 'ok';
        }

        // ----- Magic quotes trick
        $this->privSwapBackMagicQuotes();

        // ----- Return
        return $v_prop;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : duplicate()
    // Description :
    //     This method creates an archive by copying the content of an other one. If
    //     the archive already exist, it is replaced by the new one without any warning.
    // Parameters :
    //     $p_archive : The filename of a valid archive, or
    //                                a valid PclZip object.
    // Return Values :
    //     1 on success.
    //     0 or a negative value on error (error code).
    // --------------------------------------------------------------------------------
    public function duplicate($p_archive)
    {
        $v_result = 1;

        // ----- Reset the error handler
        $this->privErrorReset();

        // ----- Look if the $p_archive is a PclZip object
        if ((is_object($p_archive)) && (get_class($p_archive) == 'pclzip')) {
            // ----- Duplicate the archive
            $v_result = $this->privDuplicate($p_archive->zipname);
        } elseif (is_string($p_archive)) {
            // ----- Look if the $p_archive is a string (so a filename)
            // ----- Check that $p_archive is a valid zip file
            // TBC : Should also check the archive format
            if (!is_file($p_archive)) {
                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "No file with filename '".$p_archive."'");
                $v_result = PCLZIP_ERR_MISSING_FILE;
            } else {
                // ----- Duplicate the archive
                $v_result = $this->privDuplicate($p_archive);
            }
        } else {
            // ----- Invalid variable
            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add");
            $v_result = PCLZIP_ERR_INVALID_PARAMETER;
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : merge()
    // Description :
    //     This method merge the $p_archive_to_add archive at the end of the current
    //     one ($this).
    //     If the archive ($this) does not exist, the merge becomes a duplicate.
    //     If the $p_archive_to_add archive does not exist, the merge is a success.
    // Parameters :
    //     $p_archive_to_add : It can be directly the filename of a valid zip archive,
    //                                             or a PclZip object archive.
    // Return Values :
    //     1 on success,
    //     0 or negative values on error (see below).
    // --------------------------------------------------------------------------------
    public function merge($p_archive_to_add)
    {
        $v_result = 1;

        // ----- Reset the error handler
        $this->privErrorReset();

        // ----- Check archive
        if (!$this->privCheckFormat()) {
            return(0);
        }

        // ----- Look if the $p_archive_to_add is a PclZip object
        if ((is_object($p_archive_to_add)) && (get_class($p_archive_to_add) == 'pclzip')) {
            // ----- Merge the archive
            $v_result = $this->privMerge($p_archive_to_add);
        } elseif (is_string($p_archive_to_add)) {
            // ----- Look if the $p_archive_to_add is a string (so a filename)
            // ----- Create a temporary archive
            $v_object_archive = new PclZip($p_archive_to_add);

            // ----- Merge the archive
            $v_result = $this->privMerge($v_object_archive);
        } else {
            // ----- Invalid variable
            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add");
            $v_result = PCLZIP_ERR_INVALID_PARAMETER;
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------



    // --------------------------------------------------------------------------------
    // Function : errorCode()
    // Description :
    // Parameters :
    // --------------------------------------------------------------------------------
    public function errorCode()
    {
        if (PCLZIP_ERROR_EXTERNAL == 1) {
            return(PclErrorCode());
        } else {
            return($this->error_code);
        }
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : errorName()
    // Description :
    // Parameters :
    // --------------------------------------------------------------------------------
    public function errorName($p_with_code = false)
    {
        $v_name = array(
            PCLZIP_ERR_NO_ERROR => 'PCLZIP_ERR_NO_ERROR',
            PCLZIP_ERR_WRITE_OPEN_FAIL => 'PCLZIP_ERR_WRITE_OPEN_FAIL',
            PCLZIP_ERR_READ_OPEN_FAIL => 'PCLZIP_ERR_READ_OPEN_FAIL',
            PCLZIP_ERR_INVALID_PARAMETER => 'PCLZIP_ERR_INVALID_PARAMETER',
            PCLZIP_ERR_MISSING_FILE => 'PCLZIP_ERR_MISSING_FILE',
            PCLZIP_ERR_FILENAME_TOO_LONG => 'PCLZIP_ERR_FILENAME_TOO_LONG',
            PCLZIP_ERR_INVALID_ZIP => 'PCLZIP_ERR_INVALID_ZIP',
            PCLZIP_ERR_BAD_EXTRACTED_FILE => 'PCLZIP_ERR_BAD_EXTRACTED_FILE',
            PCLZIP_ERR_DIR_CREATE_FAIL => 'PCLZIP_ERR_DIR_CREATE_FAIL',
            PCLZIP_ERR_BAD_EXTENSION => 'PCLZIP_ERR_BAD_EXTENSION',
            PCLZIP_ERR_BAD_FORMAT => 'PCLZIP_ERR_BAD_FORMAT',
            PCLZIP_ERR_DELETE_FILE_FAIL => 'PCLZIP_ERR_DELETE_FILE_FAIL',
            PCLZIP_ERR_RENAME_FILE_FAIL => 'PCLZIP_ERR_RENAME_FILE_FAIL',
            PCLZIP_ERR_BAD_CHECKSUM => 'PCLZIP_ERR_BAD_CHECKSUM',
            PCLZIP_ERR_INVALID_ARCHIVE_ZIP => 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP',
            PCLZIP_ERR_MISSING_OPTION_VALUE => 'PCLZIP_ERR_MISSING_OPTION_VALUE',
            PCLZIP_ERR_INVALID_OPTION_VALUE => 'PCLZIP_ERR_INVALID_OPTION_VALUE',
            PCLZIP_ERR_UNSUPPORTED_COMPRESSION => 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION',
            PCLZIP_ERR_UNSUPPORTED_ENCRYPTION => 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION',
            PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE => 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE',
            PCLZIP_ERR_DIRECTORY_RESTRICTION => 'PCLZIP_ERR_DIRECTORY_RESTRICTION',
        );

        if (isset($v_name[$this->error_code])) {
            $v_value = $v_name[$this->error_code];
        } else {
            $v_value = 'NoName';
        }

        if ($p_with_code) {
            return($v_value.' ('.$this->error_code.')');
        } else {
            return($v_value);
        }
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : errorInfo()
    // Description :
    // Parameters :
    // --------------------------------------------------------------------------------
    public function errorInfo($p_full = false)
    {
        if (PCLZIP_ERROR_EXTERNAL == 1) {
            return(PclErrorString());
        } else {
            if ($p_full) {
                return($this->errorName(true)." : ".$this->error_string);
            } else {
                return($this->error_string." [code ".$this->error_code."]");
            }
        }
    }
    // --------------------------------------------------------------------------------


    // --------------------------------------------------------------------------------
    // ***** UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS *****
    // *****                                                                                                                *****
    // *****             THESES FUNCTIONS MUST NOT BE USED DIRECTLY             *****
    // --------------------------------------------------------------------------------



    // --------------------------------------------------------------------------------
    // Function : privCheckFormat()
    // Description :
    //     This method check that the archive exists and is a valid zip archive.
    //     Several level of check exists. (futur)
    // Parameters :
    //     $p_level : Level of check. Default 0.
    //                            0 : Check the first bytes (magic codes) (default value))
    //                            1 : 0 + Check the central directory (futur)
    //                            2 : 1 + Check each file header (futur)
    // Return Values :
    //     true on success,
    //     false on error, the error code is set.
    // --------------------------------------------------------------------------------
    public function privCheckFormat($p_level = 0)
    {
        $v_result = true;

        // ----- Reset the file system cache
        clearstatcache();

        // ----- Reset the error handler
        $this->privErrorReset();

        // ----- Look if the file exits
        if (!is_file($this->zipname)) {
            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "Missing archive file '".$this->zipname."'");
            return(false);
        }

        // ----- Check that the file is readeable
        if (!is_readable($this->zipname)) {
            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to read archive '".$this->zipname."'");
            return(false);
        }

        // ----- Check the magic code
        // TBC

        // ----- Check the central header
        // TBC

        // ----- Check each file header
        // TBC

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privParseOptions()
    // Description :
    //     This internal methods reads the variable list of arguments ($p_options_list,
    //     $p_size) and generate an array with the options and values ($v_result_list).
    //     $v_requested_options contains the options that can be present and those that
    //     must be present.
    //     $v_requested_options is an array, with the option value as key, and 'optional',
    //     or 'mandatory' as value.
    // Parameters :
    //     See above.
    // Return Values :
    //     1 on success.
    //     0 on failure.
    // --------------------------------------------------------------------------------
    public function privParseOptions(&$p_options_list, $p_size, &$v_result_list, $v_requested_options = false)
    {
        $v_result=1;

        // ----- Read the options
        $i=0;
        while ($i<$p_size) {
            // ----- Check if the option is supported
            if (!isset($v_requested_options[$p_options_list[$i]])) {
                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid optional parameter '".$p_options_list[$i]."' for this method");

                // ----- Return
                return PclZip::errorCode();
            }

            // ----- Look for next option
            switch ($p_options_list[$i]) {
                // ----- Look for options that request a path value
                case PCLZIP_OPT_PATH:
                case PCLZIP_OPT_REMOVE_PATH:
                case PCLZIP_OPT_ADD_PATH:
                    // ----- Check the number of parameters
                    if (($i+1) >= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], false);
                    $i++;
                    break;

                case PCLZIP_OPT_TEMP_FILE_THRESHOLD:
                    // ----- Check the number of parameters
                    if (($i+1) >= $p_size) {
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
                        return PclZip::errorCode();
                    }

                    // ----- Check for incompatible options
                    if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'");
                        return PclZip::errorCode();
                    }

                    // ----- Check the value
                    $v_value = $p_options_list[$i+1];
                    if ((!is_integer($v_value)) || ($v_value<0)) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Integer expected for option '".PclZipUtilOptionText($p_options_list[$i])."'");
                        return PclZip::errorCode();
                    }

                    // ----- Get the value (and convert it in bytes)
                    $v_result_list[$p_options_list[$i]] = $v_value*1048576;
                    $i++;
                    break;

                case PCLZIP_OPT_TEMP_FILE_ON:
                    // ----- Check for incompatible options
                    if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'");
                        return PclZip::errorCode();
                    }

                    $v_result_list[$p_options_list[$i]] = true;
                    break;

                case PCLZIP_OPT_TEMP_FILE_OFF:
                    // ----- Check for incompatible options
                    if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_ON])) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_ON'");
                        return PclZip::errorCode();
                    }
                    // ----- Check for incompatible options
                    if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_THRESHOLD'");
                        return PclZip::errorCode();
                    }
                    $v_result_list[$p_options_list[$i]] = true;
                    break;

                case PCLZIP_OPT_EXTRACT_DIR_RESTRICTION:
                    // ----- Check the number of parameters
                    if (($i+1) >= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    if (is_string($p_options_list[$i+1]) && ($p_options_list[$i+1] != '')) {
                        $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], false);
                        $i++;
                    } else {
                    }
                    break;
                // ----- Look for options that request an array of string for value
                case PCLZIP_OPT_BY_NAME:
                    // ----- Check the number of parameters
                    if (($i+1) >= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    if (is_string($p_options_list[$i+1])) {
                            $v_result_list[$p_options_list[$i]][0] = $p_options_list[$i+1];
                    } elseif (is_array($p_options_list[$i+1])) {
                            $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];
                    } else {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
                        // ----- Return
                        return PclZip::errorCode();
                    }
                    $i++;
                    break;
                // ----- Look for options that request an EREG or PREG expression
                case PCLZIP_OPT_BY_EREG:
                    // ereg() is deprecated starting with PHP 5.3. Move PCLZIP_OPT_BY_EREG
                    // to PCLZIP_OPT_BY_PREG
                    $p_options_list[$i] = PCLZIP_OPT_BY_PREG;
                case PCLZIP_OPT_BY_PREG:
                //case PCLZIP_OPT_CRYPT :
                    // ----- Check the number of parameters
                    if (($i+1) >= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    if (is_string($p_options_list[$i+1])) {
                            $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];
                    } else {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
                        // ----- Return
                        return PclZip::errorCode();
                    }
                    $i++;
                    break;

                // ----- Look for options that takes a string
                case PCLZIP_OPT_COMMENT:
                case PCLZIP_OPT_ADD_COMMENT:
                case PCLZIP_OPT_PREPEND_COMMENT:
                    // ----- Check the number of parameters
                    if (($i+1) >= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    if (is_string($p_options_list[$i+1])) {
                            $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];
                    } else {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '" .PclZipUtilOptionText($p_options_list[$i]) ."'");

                        // ----- Return
                        return PclZip::errorCode();
                    }
                    $i++;
                    break;

                // ----- Look for options that request an array of index
                case PCLZIP_OPT_BY_INDEX:
                    // ----- Check the number of parameters
                    if (($i+1) >= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    $v_work_list = array();
                    if (is_string($p_options_list[$i+1])) {
                        // ----- Remove spaces
                        $p_options_list[$i+1] = strtr($p_options_list[$i+1], ' ', '');

                        // ----- Parse items
                        $v_work_list = explode(",", $p_options_list[$i+1]);
                    } elseif (is_integer($p_options_list[$i+1])) {
                            $v_work_list[0] = $p_options_list[$i+1].'-'.$p_options_list[$i+1];
                    } elseif (is_array($p_options_list[$i+1])) {
                            $v_work_list = $p_options_list[$i+1];
                    } else {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Value must be integer, string or array for option '".PclZipUtilOptionText($p_options_list[$i])."'");

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Reduce the index list
                    // each index item in the list must be a couple with a start and
                    // an end value : [0,3], [5-5], [8-10], ...
                    // ----- Check the format of each item
                    $v_sort_flag=false;
                    $v_sort_value=0;
                    for ($j=0; $j<sizeof($v_work_list); $j++) {
                        // ----- Explode the item
                        $v_item_list = explode("-", $v_work_list[$j]);
                        $v_size_item_list = sizeof($v_item_list);

                        // ----- TBC : Here we might check that each item is a
                        // real integer ...

                        // ----- Look for single value
                        if ($v_size_item_list == 1) {
                            // ----- Set the option value
                            $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];
                            $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[0];
                        } elseif ($v_size_item_list == 2) {
                            // ----- Set the option value
                            $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];
                            $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[1];
                        } else {
                            // ----- Error log
                            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Too many values in index range for option '".PclZipUtilOptionText($p_options_list[$i])."'");

                            // ----- Return
                            return PclZip::errorCode();
                        }


                        // ----- Look for list sort
                        if ($v_result_list[$p_options_list[$i]][$j]['start'] < $v_sort_value) {
                            $v_sort_flag=true;

                            // ----- TBC : An automatic sort should be writen ...
                            // ----- Error log
                            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Invalid order of index range for option '".PclZipUtilOptionText($p_options_list[$i])."'");

                            // ----- Return
                            return PclZip::errorCode();
                        }
                        $v_sort_value = $v_result_list[$p_options_list[$i]][$j]['start'];
                    }

                    // ----- Sort the items
                    if ($v_sort_flag) {
                        // TBC : To Be Completed
                    }
                    // ----- Next option
                    $i++;
                    break;
                // ----- Look for options that request no value
                case PCLZIP_OPT_REMOVE_ALL_PATH:
                case PCLZIP_OPT_EXTRACT_AS_STRING:
                case PCLZIP_OPT_NO_COMPRESSION:
                case PCLZIP_OPT_EXTRACT_IN_OUTPUT:
                case PCLZIP_OPT_REPLACE_NEWER:
                case PCLZIP_OPT_STOP_ON_ERROR:
                    $v_result_list[$p_options_list[$i]] = true;
                    break;
                // ----- Look for options that request an octal value
                case PCLZIP_OPT_SET_CHMOD:
                    // ----- Check the number of parameters
                    if (($i+1) >= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
                        // ----- Return
                        return PclZip::errorCode();
                    }
                    // ----- Get the value
                    $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];
                    $i++;
                    break;

                // ----- Look for options that request a call-back
                case PCLZIP_CB_PRE_EXTRACT:
                case PCLZIP_CB_POST_EXTRACT:
                case PCLZIP_CB_PRE_ADD:
                case PCLZIP_CB_POST_ADD:
                /* for futur use
                case PCLZIP_CB_PRE_DELETE :
                case PCLZIP_CB_POST_DELETE :
                case PCLZIP_CB_PRE_LIST :
                case PCLZIP_CB_POST_LIST :
                */
                    // ----- Check the number of parameters
                    if (($i+1) >= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    $v_function_name = $p_options_list[$i+1];

                    // ----- Check that the value is a valid existing function
                    if (!function_exists($v_function_name)) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Function '".$v_function_name."()' is not an existing function for option '".PclZipUtilOptionText($p_options_list[$i])."'");
                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Set the attribute
                    $v_result_list[$p_options_list[$i]] = $v_function_name;
                    $i++;
                    break;
                default:
                    // ----- Error log
                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Unknown parameter '" .$p_options_list[$i]."'");

                    // ----- Return
                    return PclZip::errorCode();
            }

            // ----- Next options
            $i++;
        }

        // ----- Look for mandatory options
        if ($v_requested_options !== false) {
            for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {
                // ----- Look for mandatory option
                if ($v_requested_options[$key] == 'mandatory') {
                    // ----- Look if present
                    if (!isset($v_result_list[$key])) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter ".PclZipUtilOptionText($key)."(".$key.")");

                        // ----- Return
                        return PclZip::errorCode();
                    }
                }
            }
        }

        // ----- Look for default values
        if (!isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privOptionDefaultThreshold()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privOptionDefaultThreshold(&$p_options)
    {
        $v_result=1;

        if (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]) || isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) {
            return $v_result;
        }

        // ----- Get 'memory_limit' configuration value
        $v_memory_limit = ini_get('memory_limit');
        $v_memory_limit = trim($v_memory_limit);
        $last = strtolower(substr($v_memory_limit, -1));

        if ($last == 'g') {
            //$v_memory_limit = $v_memory_limit*1024*1024*1024;
            $v_memory_limit = $v_memory_limit*1073741824;
        }
        if ($last == 'm') {
            //$v_memory_limit = $v_memory_limit*1024*1024;
            $v_memory_limit = $v_memory_limit*1048576;
        }
        if ($last == 'k') {
            $v_memory_limit = $v_memory_limit*1024;
        }

        $p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor($v_memory_limit*PCLZIP_TEMPORARY_FILE_RATIO);

        // ----- Sanity check : No threshold if value lower than 1M
        if ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] < 1048576) {
            unset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]);
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privFileDescrParseAtt()
    // Description :
    // Parameters :
    // Return Values :
    //     1 on success.
    //     0 on failure.
    // --------------------------------------------------------------------------------
    public function privFileDescrParseAtt(&$p_file_list, &$p_filedescr, $v_options, $v_requested_options = false)
    {
        $v_result=1;

        // ----- For each file in the list check the attributes
        foreach ($p_file_list as $v_key => $v_value) {
            // ----- Check if the option is supported
            if (!isset($v_requested_options[$v_key])) {
                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file attribute '".$v_key."' for this file");

                // ----- Return
                return PclZip::errorCode();
            }

            // ----- Look for attribute
            switch ($v_key) {
                case PCLZIP_ATT_FILE_NAME:
                    if (!is_string($v_value)) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");
                  